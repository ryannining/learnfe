<!DOCTYPE html>
<html>
    <head>
        <title>Sunlight Intensity on Earth</title>
        <style>
            canvas {
                border: 1px solid black;
            }
        </style>
    </head>
    <body>
        <div>
            <label for="dayOfYearInput">Day of Year:</label>
            <input type="text" id="dayOfYearInput" value="100"/>
            <label for="timeOfDayInput">Time of Day (in hours):</label>
            <input type="text" id="timeOfDayInput" value="12"/>
            <button onclick="go1()">Redraw</button><button onclick="go2()">Animasikan</button>
        </div>
        <canvas id="canvas" width="800" height="400"></canvas>
        <canvas id="equidistantCanvas" width="400" height="400"></canvas>
        <canvas id="canvas3d" width="400" height="400"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
        <script src="images2.js"></script>
        <script>


            
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const latitudeLines = Math.floor(180 / 15) + 1;
            // Number of latitude lines
            const longitudeLines = Math.floor(360 / 15) + 1;
            // Number of longitude lines

            const canvas2 = document.getElementById('equidistantCanvas');
            const ctx2 = canvas2.getContext('2d');

            const canvas3d=document.getElementById('canvas3d');
            const renderer = new THREE.WebGLRenderer({ canvas: canvas3d });
            renderer.setSize(canvas3d.clientWidth, canvas3d.clientHeight,true);
            renderer.setPixelRatio(window.devicePixelRatio);
            
const scene = new THREE.Scene();
const texture = new THREE.CanvasTexture(canvas);
const camera = new THREE.OrthographicCamera(
  canvas3d.clientWidth / -2,
  canvas3d.clientWidth / 2,
  canvas3d.clientHeight / 2,
  canvas3d.clientHeight / -2,
  1,
  1000
);
            
          // Create a sphere
const geometry = new THREE.SphereGeometry(150, 32, 32);
const material = new THREE.MeshBasicMaterial({ map: texture });
const sphere = new THREE.Mesh(geometry, material);
scene.add(sphere);
const ambientLight = new THREE.AmbientLight(0xffffff, 1);
scene.add(ambientLight);
camera.position.z=200;


            solarDeclination=0;
            function calculateSunlightIntensity(latitude, longitude, dayOfYear, timeOfDay) {
                // Convert latitude and longitude to radians
                const latitudeRad = latitude * Math.PI / 180;
                const longitudeRad = longitude * Math.PI / 180;

                // Calculate time difference from noon
                const timeDifference = (timeOfDay - 12) * 15;
                // 15 degrees per hour

                // Calculate solar declination angle
                 solarDeclination = 0.409 * Math.sin(((2 * Math.PI / 365) * dayOfYear) - 1.39);

                // Calculate hour angle
                const hourAngle = -timeDifference * Math.PI / 180 - longitudeRad + Math.PI;

                // Calculate solar zenith angle
                const cosZenithAngle = Math.sin(latitudeRad) * Math.sin(solarDeclination) + Math.cos(latitudeRad) * Math.cos(solarDeclination) * Math.cos(hourAngle);
                const zenithAngle = Math.acos(cosZenithAngle);

                // Calculate extraterrestrial radiation
                const distanceFromSun = 149.6 * 10 ** 6;
                // km
                const extraterrestrialRadiation = 1367 / (distanceFromSun ** 2);

                // Calculate air mass
                const airMass = 1 / cosZenithAngle;

                // Calculate atmospheric transmittance
                const waterVapor = 0.1;
                // cm
                const aerosols = 0.1;
                // unitless
                const ozone = 0.3;
                // cm
                const airMassPath = 1 / Math.cos(zenithAngle);
                const atmosphericTransmittance = Math.exp(-0.866 * (waterVapor + aerosols)) * Math.exp(-0.0127 * ozone * airMassPath);
                if (isNaN(atmosphericTransmittance))
                    atmosphericTransmittance = 1;
                // Calculate solar radiation
                const solarRadiation = extraterrestrialRadiation * cosZenithAngle * atmosphericTransmittance;

                return Math.max(0,atmosphericTransmittance * cosZenithAngle) * 3;
            }
            function updateTexture() {
              texture.needsUpdate = true;
            }

            function render() {
                // Draw latitude and longitude lines
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
                ctx.lineWidth=1;

                // Draw circles representing sunlight intensity
                const latIncrement = canvas.height / latitudeLines;
                const lonIncrement = canvas.width / longitudeLines;

                for (let latIndex = 0; latIndex < latitudeLines; latIndex++) {
                    for (let lonIndex = 0; lonIndex < longitudeLines; lonIndex++) {
                        const latitude = (latIndex / latitudeLines) * 180 - 90;
                        const longitude = (lonIndex / longitudeLines) * 360 - 180;

                        const intensity = 0.95 - calculateSunlightIntensity(latitude, longitude, dayOfYear, timeOfDay);

                        const x = lonIndex * lonIncrement;
                        const y = latIndex * latIncrement;

                        const circleSize = Math.min(latIncrement, lonIncrement) / 2;

                        ctx.fillStyle = `rgba(0,0,0, ${intensity})`;
                        ctx.beginPath();

                        //ctx.arc(x + circleSize, y + circleSize, 3, 0, Math.PI * 2);
                        ctx.fillRect(x, y, lonIncrement, latIncrement);


                    }

                }

                // Draw latitude lines
                ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                ctx.font = '12px Arial';
                ctx.fillStyle = 'yellow';
                ctx.lineWidth=0.5;
                let oldl=-250;
                for (let i = 0; i <= latitudeLines; i++) {
                    const y = (canvas.height / latitudeLines) * i;
                    const latitude = (i / (latitudeLines - 1)) * 180 - 90;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                    if (latitude-oldl>=30){
                      ctx.fillText(`${latitude.toFixed(0)}`, 5, y+15);
                      oldl=latitude;
                    }                }

                // Draw longitude lines
                ctx.fillStyle = 'cyan';
                oldl=-10;
                for (let i = 0; i <= longitudeLines; i++) {
                    const x = (canvas.width / longitudeLines) * i;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                    const longitude = (i / (longitudeLines - 1)) * 360;
                    if (longitude-oldl>=30){
                      ctx.fillText(`${longitude.toFixed(0)}`, x-10, canvas.height-12);
                      oldl=longitude;
                    }
                }

                
                ctx2.fillStyle = '#00F000';
                ctx2.fillRect(0, 0, canvas2.width, canvas2.height);
                const tData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const tdata = tData.data;
                const imageData = ctx2.createImageData(canvas2.width, canvas2.height);
                const data = new Uint8ClampedArray(imageData.data.buffer);
                const rc=canvas2.width/2;
                cw=Math.floor(canvas2.width*2);
                for (let sj=0;sj<cw;sj++){
                  let j=Math.floor(sj*canvas.height/(canvas2.width*2));
                  let r=1+cw*1.5*sj/cw;
                  let r1=r/(2*Math.PI);
                  for (let i=0;i<r;i++){
                    let d=i*2*Math.PI/r;
                    let idx=4*(j*canvas.width+Math.floor(i*canvas.width/r));
                    
                    let idx2=(Math.floor(rc+Math.sin(d)*r1)*canvas2.width+
                         Math.floor(rc+Math.cos(d)*r1))*4;
                    data[idx2]=tdata[idx];
                    data[idx2+1]=tdata[idx+1];
                    data[idx2+2]=tdata[idx+2];
                    
                    data[idx2+3]=255;
                  }
                }
                ctx2.putImageData(imageData, 0, 0);
                sphere.rotation.y += 0.01;
                texture.needsUpdate = true;
                camera.position.y=-Math.sin(solarDeclination)*150;
                camera.lookAt(sphere.position);
                camera.updateProjectionMatrix();
                renderer.render(scene, camera);
                if (animasikan){
                  timeOfDay += 0.1;
                  if (timeOfDay > 24) {
                      timeOfDay = timeOfDay - 24;
                      dayOfYear += 1;
                      if (dayOfYear > 365)
                          dayOfYear = 0;
                  }
                  document.getElementById('dayOfYearInput').value = dayOfYear;
                  document.getElementById('timeOfDayInput').value = timeOfDay.toFixed(2);
                  // update 3d object
                  requestAnimationFrame(render);
                }
            }
            dayOfYear = 0;
            timeOfDay = 0;
            animasikan=false;
            function go2(){
              animasikan=!animasikan;
              go1();
            }
            function go1() {
                dayOfYear = parseInt(document.getElementById('dayOfYearInput').value);
                timeOfDay = parseInt(document.getElementById('timeOfDayInput').value);
                render();
            }
            image.onload = function() {
                go1();
            }
        </script>
    </body>
</html>
